<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue源码分析 | blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/logo.png">
    <meta name="description" content="不积硅步无以至千里">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b6bfb1ac.css" as="style"><link rel="preload" href="/blog/assets/js/app.ae7031d7.js" as="script"><link rel="preload" href="/blog/assets/js/2.291a984f.js" as="script"><link rel="preload" href="/blog/assets/js/26.939f8909.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.72636907.js"><link rel="prefetch" href="/blog/assets/js/11.b1bcfd3f.js"><link rel="prefetch" href="/blog/assets/js/12.ae6b4d89.js"><link rel="prefetch" href="/blog/assets/js/13.92b17d06.js"><link rel="prefetch" href="/blog/assets/js/14.2d04dfa0.js"><link rel="prefetch" href="/blog/assets/js/15.604b6eb3.js"><link rel="prefetch" href="/blog/assets/js/16.8b80cbf6.js"><link rel="prefetch" href="/blog/assets/js/17.7e5c6124.js"><link rel="prefetch" href="/blog/assets/js/18.2b696122.js"><link rel="prefetch" href="/blog/assets/js/19.22ab6150.js"><link rel="prefetch" href="/blog/assets/js/20.c1b4e9ea.js"><link rel="prefetch" href="/blog/assets/js/21.382beea0.js"><link rel="prefetch" href="/blog/assets/js/22.ae61ce8d.js"><link rel="prefetch" href="/blog/assets/js/23.b6115d56.js"><link rel="prefetch" href="/blog/assets/js/24.36644d3b.js"><link rel="prefetch" href="/blog/assets/js/25.526d93c7.js"><link rel="prefetch" href="/blog/assets/js/27.14b4c521.js"><link rel="prefetch" href="/blog/assets/js/28.22c44d76.js"><link rel="prefetch" href="/blog/assets/js/29.584e4d25.js"><link rel="prefetch" href="/blog/assets/js/3.c2920542.js"><link rel="prefetch" href="/blog/assets/js/30.e1efe460.js"><link rel="prefetch" href="/blog/assets/js/4.85c7a3bf.js"><link rel="prefetch" href="/blog/assets/js/5.fc256868.js"><link rel="prefetch" href="/blog/assets/js/6.e236ba0e.js"><link rel="prefetch" href="/blog/assets/js/7.6909b162.js"><link rel="prefetch" href="/blog/assets/js/8.c5af3541.js"><link rel="prefetch" href="/blog/assets/js/9.ceb9e4f4.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b6bfb1ac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/base/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/blog/webImprove/" class="nav-link">
  前端进阶
</a></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/blog/write/" class="nav-link">
  手写
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link router-link-active">
  vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  react
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  node
</a></div> <a href="https://github.com/docschina/vuepress" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/base/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/blog/webImprove/" class="nav-link">
  前端进阶
</a></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/blog/write/" class="nav-link">
  手写
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link router-link-active">
  vue
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  react
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  node
</a></div> <a href="https://github.com/docschina/vuepress" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/vue/" aria-current="page" class="sidebar-link">vue基础</a></li><li><a href="/blog/vue/vue源码分析.html" class="active sidebar-link">vue源码分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_1-v-if和v-for哪个优先级更高-同时出现-如何优化" class="sidebar-link">1.v-if和v-for哪个优先级更高？同时出现 如何优化？</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_2-vue组件data为什么必须是个函数而vue的根实例没有这个限制" class="sidebar-link">2.Vue组件data为什么必须是个函数而Vue的根实例没有这个限制？</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_3-vue中的key的作用和工作原理" class="sidebar-link">3.Vue中的key的作用和工作原理？</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_4-怎么理解vue中的diff算法" class="sidebar-link">4.怎么理解vue中的diff算法？</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_5-vue组件化的理解" class="sidebar-link">5.Vue组件化的理解？</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_6-谈一谈vue设计原则" class="sidebar-link">6.谈一谈vue设计原则？</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_7-你了解哪些vue的性能优化方法-代码层面" class="sidebar-link">7.你了解哪些Vue的性能优化方法(代码层面)？</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_8-对3-0的新特性有没有了解" class="sidebar-link">8.对3.0的新特性有没有了解？</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_9-computed的实现原理" class="sidebar-link">9.computed的实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/vue/vue源码分析.html#_10-vue对数组做了哪些处理" class="sidebar-link">10.vue对数组做了哪些处理</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue源码分析"><a href="#vue源码分析" class="header-anchor">#</a> vue源码分析</h1> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>将回答问题的方式、思路和层次提升一个层级</p></div> <h2 id="_1-v-if和v-for哪个优先级更高-同时出现-如何优化"><a href="#_1-v-if和v-for哪个优先级更高-同时出现-如何优化" class="header-anchor">#</a> 1.v-if和v-for哪个优先级更高？同时出现 如何优化？</h2> <blockquote><p>源码 compiler/condegen/index.js</p></blockquote> <h4 id="结论"><a href="#结论" class="header-anchor">#</a> 结论</h4> <ul><li>1.显然v-for的优先级高于v-if (codegenindex源码中顺序为el.once &gt; el.for &lt; el.if)</li> <li>2.如果同时出现，每次渲染都会先执行循环在判断，循环不可避免，浪费性能</li> <li>3.将v-if提到外面一层，内部进行v-for循环</li></ul> <h2 id="_2-vue组件data为什么必须是个函数而vue的根实例没有这个限制"><a href="#_2-vue组件data为什么必须是个函数而vue的根实例没有这个限制" class="header-anchor">#</a> 2.Vue组件data为什么必须是个函数而Vue的根实例没有这个限制？</h2> <blockquote><p>源码 src/core/instance/state.js - initData()</p></blockquote> <h4 id="结论-2"><a href="#结论-2" class="header-anchor">#</a> 结论</h4> <ul><li>Vue组件可能存在多个实例，如果使用对象形式定义data,他们将会公用一个data对象，状态改变将会
影响多个组件实例;采用函数定义，在initData时会返回一个全新的data对象，避免多实例的状态污染。
Vue跟实例不会出现这个问题，是因为根实例只能有一个。</li></ul> <h2 id="_3-vue中的key的作用和工作原理"><a href="#_3-vue中的key的作用和工作原理" class="header-anchor">#</a> 3.Vue中的key的作用和工作原理？</h2> <blockquote><p>源码 src/core/vdom/patch.js - updateChildren()</p></blockquote> <h4 id="结论-3"><a href="#结论-3" class="header-anchor">#</a> 结论</h4> <ul><li>1.key的主要作用是为了更高效的更新虚拟Dom,其原理是vue在patch过程中通过key可以精准的判断两个节点
是否是同一个，避免频繁更新不同的元素，会让整个patch过程更加高效，减少dom操作，提高性能。</li> <li>2.若不设置key还可能在列表更新引发一些隐藏的bug</li></ul> <h2 id="_4-怎么理解vue中的diff算法"><a href="#_4-怎么理解vue中的diff算法" class="header-anchor">#</a> 4.怎么理解vue中的diff算法？</h2> <blockquote><p>源码分析1：必要性 lifecycle.js - mountConponent()
组件中可能存在很多个data中的key使用
源码分析2：执行方法 patch.js- patchVnode()
patchVnode是diff发生的地方 整体策略:深度优先，同级比较
源码分析3：高效性 patch.js -updateChildren()</p></blockquote> <h4 id="结论-4"><a href="#结论-4" class="header-anchor">#</a> 结论</h4> <ul><li>1.diff算法是虚拟DOM的必然产物：通过新旧虚拟DOM作对比，将变化的地方更新在真实的DOM上，
另外，也需要diff高效的执行对比过程。</li> <li>2.vue 2.x中为了降低Watcher粒度，每个组件只有一个watcher与之对应，只有引入diff才能精确找到
变化的地方。</li> <li>3.vue中diff执行的时刻是组件实例执行其更新函数时，它会对比上一次渲染结果的oldVnode和新的渲染结果
newVnode,此过程称为patch。</li></ul> <h2 id="_5-vue组件化的理解"><a href="#_5-vue组件化的理解" class="header-anchor">#</a> 5.Vue组件化的理解？</h2> <blockquote><p>组件化定义，优点，使用场景和注意事项。
源码分析1：组件定义 src/core/global-api/assets.js
vue-loader会编译template为render函数，最终导出的依然是组件配置对象。
源码分析2：组件化优点 lifecycle.js = mountComponent()
组件、watcher、渲染函数和更新函数之间的关系
源码分析3：组件化实现 src/code/global-api/extend.js
实例化及挂载，src/core/vdom/patch.js - createElm()</p></blockquote> <h4 id="结论-5"><a href="#结论-5" class="header-anchor">#</a> 结论</h4> <ul><li>1.组件化是软件工程中的一种思想，组件是独立和可复用的代码单元。组件是vue核心特性之一。</li> <li>2.组件化开发能大幅度提高效率，测试性，复用性。</li> <li>3.组件按分类有：页面组件，业务组件，通用组件。</li> <li>4.vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，
他们是基于vueComponent,拓展于Vue；</li> <li>5.vue中常见的组件化：属性prop,自定义事件，插槽。</li> <li>6.组件应该是高内聚，低耦合的。</li> <li>7.遵循单向数据流的原则。</li></ul> <h2 id="_6-谈一谈vue设计原则"><a href="#_6-谈一谈vue设计原则" class="header-anchor">#</a> 6.谈一谈vue设计原则？</h2> <ul><li>1.渐进式js框架</li> <li>2.易用 灵活 高效</li></ul> <h2 id="_7-你了解哪些vue的性能优化方法-代码层面"><a href="#_7-你了解哪些vue的性能优化方法-代码层面" class="header-anchor">#</a> 7.你了解哪些Vue的性能优化方法(代码层面)？</h2> <ul><li>1.路由懒加载</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">component</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;./xx.vue&quot;</span><span class="token punctuation">)</span>

</code></pre></div><ul><li>2.keep-alive 缓存页面</li></ul> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive include<span class="token operator">=</span><span class="token string">&quot;getProcess&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
</code></pre></div><ul><li>3.使用v-show复用dom</li> <li>4.v-for 遍历避免同时使用v-if</li> <li>5.长列表性能优化
<ul><li>如果列表是纯粹的数据展示，Object,freeze()冻结</li> <li>如果是大数据长列表 可采用虚拟滚动。 vue-virtual-scroller</li></ul></li> <li>6.图片懒加载</li> <li>7.第三方插件按需引入</li> <li>8.无状态的组件标记为函数式组件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template functional<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;tab&quot;</span><span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;props.value&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>    
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><h2 id="_8-对3-0的新特性有没有了解"><a href="#_8-对3-0的新特性有没有了解" class="header-anchor">#</a> 8.对3.0的新特性有没有了解？</h2> <ul><li>更快
<ul><li>虚拟DOM重写</li> <li>优化slots的生成</li> <li>静态属性提升</li> <li>基于proxy的响应式系统</li></ul></li> <li>更小：优化核心库体积</li> <li>更易维护：Ts+模块化</li> <li>更加优化</li> <li>更容易使用</li></ul> <h2 id="_9-computed的实现原理"><a href="#_9-computed的实现原理" class="header-anchor">#</a> 9.computed的实现原理</h2> <ul><li>1.当组件初始化的时候，computed 和 data 会分别建立各自的响应系统，Observer遍历 data 中每个属性设置 get/set 数据拦截</li> <li>2.初始化 computed 会调用 initComputed 函数
<ul><li>1.注册一个 watcher 实例，并在内实例化一个 Dep 消息订阅器用作后续收集依赖（比如渲染函数的 watcher 或者其他观察该计算属性变化的 watcher</li> <li>2.调用计算属性时会触发其Object.defineProperty的get访问器函数</li> <li>3.调用 watcher.depend() 方法向自身的消息订阅器 dep 的 subs 中添加其他属性的 watcher</li> <li>4.调用 watcher 的 evaluate 方法（进而调用 watcher 的 get 方法）让自身成为其他 watcher 的消息订阅器的订阅者，首先将 watcher 赋给 Dep.target，然后执行 getter 求值函数，当访问求值函数里面的属性（比如来自 data、props 或其他 computed）时，会同样触发它们的 get 访问器函数从而将该计算属性的 watcher 添加到求值函数中属性的 watcher 的消息订阅器 dep 中，当这些操作完成，最后关闭 Dep.target 赋为 null 并返回求值函数结果</li></ul></li> <li>3.当某个属性发生变化，触发 set 拦截函数，然后调用自身消息订阅器 dep 的 notify 方法，遍历当前 dep 中保存着所有订阅者 wathcer 的 subs 数组，并逐个调用 watcher 的 update 方法，完成响应更新</li></ul> <h2 id="_10-vue对数组做了哪些处理"><a href="#_10-vue对数组做了哪些处理" class="header-anchor">#</a> 10.vue对数组做了哪些处理</h2> <p>Object.defineProperty不支持监听数组变化。所以需要重写数组上面的方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token comment">//原生Array的原型</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token comment">//缓存元素数组原型</span>
  <span class="token comment">//这里重写了数组的几个原型方法</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//这里备份一份参数应该是从性能方面的考虑</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token comment">//原始方法求值</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__<span class="token comment">//这里this.__ob__指向的是数据的Observer</span>
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">//定义属性</span>
<span class="token keyword">function</span> <span class="token function">def</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> enumerable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> val<span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token operator">!</span><span class="token operator">!</span>enumerable<span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>第一步：先获取原生 Array 的原型方法，因为拦截后还是需要原生的方法帮我们实现数组的变化。</li> <li>第二步：对 Array 的原型方法使用 Object.defineProperty 做一些劫持拦截操作。</li> <li>第三步：把需要被拦截的 Array 类型的数据原型指向改造后原型。
Vue在observer数据阶段会判断如果是数组的话，则修改数组的原型，这样的话，后面对数组的任何操作都可以在劫持的过程中控制。</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/docschina/vuepress/edit/master/docs/vue/vue源码分析.md" target="_blank" rel="noopener noreferrer">编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2/4/2021, 6:06:46 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/vue/" class="prev router-link-active">
        vue基础
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.ae7031d7.js" defer></script><script src="/blog/assets/js/2.291a984f.js" defer></script><script src="/blog/assets/js/26.939f8909.js" defer></script>
  </body>
</html>
