<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue基础 | mxBlog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/logo.png">
    <meta name="description" content="不积硅步无以至千里">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b6bfb1ac.css" as="style"><link rel="preload" href="/blog/assets/js/app.03951f9c.js" as="script"><link rel="preload" href="/blog/assets/js/2.7ce02919.js" as="script"><link rel="preload" href="/blog/assets/js/11.d6ff424e.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.c0040bef.js"><link rel="prefetch" href="/blog/assets/js/12.fe187a0d.js"><link rel="prefetch" href="/blog/assets/js/13.16f89c29.js"><link rel="prefetch" href="/blog/assets/js/14.5bfc1327.js"><link rel="prefetch" href="/blog/assets/js/15.36b07f8e.js"><link rel="prefetch" href="/blog/assets/js/16.44576d76.js"><link rel="prefetch" href="/blog/assets/js/17.362b9a77.js"><link rel="prefetch" href="/blog/assets/js/18.0d88b507.js"><link rel="prefetch" href="/blog/assets/js/19.91381002.js"><link rel="prefetch" href="/blog/assets/js/20.eae1cedf.js"><link rel="prefetch" href="/blog/assets/js/21.eef060c7.js"><link rel="prefetch" href="/blog/assets/js/22.a67a6205.js"><link rel="prefetch" href="/blog/assets/js/23.90f6eb2b.js"><link rel="prefetch" href="/blog/assets/js/24.4c0f7c7c.js"><link rel="prefetch" href="/blog/assets/js/25.9fa8bf78.js"><link rel="prefetch" href="/blog/assets/js/26.94f7128a.js"><link rel="prefetch" href="/blog/assets/js/27.d84d5eb2.js"><link rel="prefetch" href="/blog/assets/js/28.519dd7f4.js"><link rel="prefetch" href="/blog/assets/js/29.8dec8ec4.js"><link rel="prefetch" href="/blog/assets/js/3.2bad3dc7.js"><link rel="prefetch" href="/blog/assets/js/30.614c71d0.js"><link rel="prefetch" href="/blog/assets/js/31.7e6a2d97.js"><link rel="prefetch" href="/blog/assets/js/32.75ff77fc.js"><link rel="prefetch" href="/blog/assets/js/33.7e546ae2.js"><link rel="prefetch" href="/blog/assets/js/34.0f95ecc0.js"><link rel="prefetch" href="/blog/assets/js/35.03ee5c2a.js"><link rel="prefetch" href="/blog/assets/js/4.b99494c6.js"><link rel="prefetch" href="/blog/assets/js/5.859a093c.js"><link rel="prefetch" href="/blog/assets/js/6.0b073004.js"><link rel="prefetch" href="/blog/assets/js/7.8e49328b.js"><link rel="prefetch" href="/blog/assets/js/8.a2494593.js"><link rel="prefetch" href="/blog/assets/js/9.739a4e63.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b6bfb1ac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">mxBlog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/base/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/blog/webImprove/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/blog/write/" class="nav-link">
  手写
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/vueBase/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue基础
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/blog/reactBase/" class="nav-link">
  React基础
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/test/" class="nav-link">
  大厂真题
</a></div><div class="nav-item"><a href="/blog/typeScript/" class="nav-link">
  TypeScript
</a></div> <a href="https://github.com/docschina/vuepress" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/base/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/blog/webImprove/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  webpack
</a></div><div class="nav-item"><a href="/blog/write/" class="nav-link">
  手写
</a></div><div class="nav-item"><a href="/blog/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/vueBase/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue基础
</a></div><div class="nav-item"><a href="/blog/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/blog/reactBase/" class="nav-link">
  React基础
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/test/" class="nav-link">
  大厂真题
</a></div><div class="nav-item"><a href="/blog/typeScript/" class="nav-link">
  TypeScript
</a></div> <a href="https://github.com/docschina/vuepress" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/vueBase/" aria-current="page" class="active sidebar-link">vue基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vueBase/#_1-vue-js是什么" class="sidebar-link">1.Vue.js是什么</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_2-vue-js特点" class="sidebar-link">2.Vue.js特点</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_3-mvvm模式" class="sidebar-link">3.MVVM模式</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_4-vue-的双向绑定的原理" class="sidebar-link">4.vue 的双向绑定的原理</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_5-keep-alive" class="sidebar-link">5.keep-alive</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_6-nexttick用法" class="sidebar-link">6.nextTick用法</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_7-对-vue-生命周期的理解" class="sidebar-link">7.对 Vue 生命周期的理解？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_8-每个周期具体适合哪些场景" class="sidebar-link">8.每个周期具体适合哪些场景</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_9-组件之间如何传值" class="sidebar-link">9.组件之间如何传值？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_10-vue路由传参数" class="sidebar-link">10.vue路由传参数</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_11-vuex-是什么-有哪几种属性" class="sidebar-link">11.vuex 是什么？ 有哪几种属性？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_12-vue-router-有哪几种导航钩子" class="sidebar-link">12.vue-router 有哪几种导航钩子?</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_13-v-model的原理" class="sidebar-link">13.v-model的原理？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_14-vue中key的原理" class="sidebar-link">14.vue中key的原理？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_15-使用vue渲染大量数据时应该怎么优化" class="sidebar-link">15.使用vue渲染大量数据时应该怎么优化</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_16-provide和inject的理解" class="sidebar-link">16.provide和inject的理解</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_17-vuex-的mutation和action的特性是什么-有什么区别" class="sidebar-link">17.vuex 的mutation和action的特性是什么？有什么区别？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_18-为什么vue中-data-必须是一个函数" class="sidebar-link">18.为什么vue中 data 必须是一个函数？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_19-axios封装" class="sidebar-link">19.axios封装</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_20-virtual-dom-的优势在哪里" class="sidebar-link">20.Virtual Dom 的优势在哪里？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_21-单页应用有那些优缺点" class="sidebar-link">21.单页应用有那些优缺点？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_22-common-js-和-es6-中模块引入的区别" class="sidebar-link">22.common.js 和 es6 中模块引入的区别？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_23-vue3今年发布了-请你说一下他们之间在相应式的实现上有什么区别-proxy-相比于-defineproperty-的优势" class="sidebar-link">23.vue3今年发布了，请你说一下他们之间在相应式的实现上有什么区别？Proxy 相比于 defineProperty 的优势</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_25-像vue-router-vuex他们都是作为vue插件-请说一下他们分别都是如何在vue中生效的" class="sidebar-link">25.像vue-router，vuex他们都是作为vue插件，请说一下他们分别都是如何在vue中生效的？</a></li><li class="sidebar-sub-header"><a href="/blog/vueBase/#_26-请你说一下vue的设计架构" class="sidebar-link">26.请你说一下vue的设计架构</a></li></ul></li><li><a href="/blog/vueBase/vue源码分析.html" class="sidebar-link">vue源码分析</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue基础"><a href="#vue基础" class="header-anchor">#</a> vue基础</h1> <h2 id="_1-vue-js是什么"><a href="#_1-vue-js是什么" class="header-anchor">#</a> 1.Vue.js是什么</h2> <p>Vue.js（是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件</p> <h2 id="_2-vue-js特点"><a href="#_2-vue-js特点" class="header-anchor">#</a> 2.Vue.js特点</h2> <ul><li>数据驱动：自动计算属性和追踪依赖的模板表达式</li> <li>组件化：用可复用、解耦的组件来构造页面</li> <li>轻量：代码量小，不依赖其他库</li> <li>快速：精确有效批量DOM更新</li></ul> <h2 id="_3-mvvm模式"><a href="#_3-mvvm模式" class="header-anchor">#</a> 3.MVVM模式</h2> <p>即Model-View-ViewModel</p> <p>MVVM 由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p> <p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p> <p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p> <h2 id="_4-vue-的双向绑定的原理"><a href="#_4-vue-的双向绑定的原理" class="header-anchor">#</a> 4.vue 的双向绑定的原理</h2> <p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p> <p><img src="/blog/assets/img/vue-model.da19bfba.jpg" alt="dd"></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。</p> <p>Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</p> <p>Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</p> <p>Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。</p></div> <p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。</p> <p>当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</p> <p>Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变</p> <h2 id="_5-keep-alive"><a href="#_5-keep-alive" class="header-anchor">#</a> 5.keep-alive</h2> <p>keep-alive是Vue提供的一个抽象组件，主要用于保留组件状态或避免重新渲染
<!----></p> <h2 id="_6-nexttick用法"><a href="#_6-nexttick用法" class="header-anchor">#</a> 6.nextTick用法</h2> <p>在下次 DOM 更新循环结束之后执行延迟回调</p> <h2 id="_7-对-vue-生命周期的理解"><a href="#_7-对-vue-生命周期的理解" class="header-anchor">#</a> 7.对 Vue 生命周期的理解？</h2> <p>开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程
总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p> <p>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有</p> <p>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染</p> <p>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法</p> <p>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p> <h2 id="_8-每个周期具体适合哪些场景"><a href="#_8-每个周期具体适合哪些场景" class="header-anchor">#</a> 8.每个周期具体适合哪些场景</h2> <p>beforecreate : 可以在这加个loading事件，在加载实例时触发
created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数
beforeDestroy : 可以做一个确认停止事件的确认框</p> <h2 id="_9-组件之间如何传值"><a href="#_9-组件之间如何传值" class="header-anchor">#</a> 9.组件之间如何传值？</h2> <ul><li>1.props / $emit</li> <li>2.vuex</li> <li>3.provide/ inject</li> <li>4.ref / refs</li> <li>5.$children / $parent</li> <li>6.eventBus等</li></ul> <h2 id="_10-vue路由传参数"><a href="#_10-vue路由传参数" class="header-anchor">#</a> 10.vue路由传参数</h2> <ul><li>1.使用query方法传入的参数使用this.$route.query接受</li> <li>2.使用params方式传入的参数使用this.$route.params接受</li></ul> <h2 id="_11-vuex-是什么-有哪几种属性"><a href="#_11-vuex-是什么-有哪几种属性" class="header-anchor">#</a> 11.vuex 是什么？ 有哪几种属性？</h2> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p> <p>有 5 种，分别是 state、getter、mutation、action、module</p> <ul><li>vuex 的 store 是什么？
vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</li> <li>vuex 的 getter 是什么？
getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters</li> <li>vuex 的 mutation 是什么？
更改Vuex的store中的状态的唯一方法是提交mutation</li> <li>vuex 的 action 是什么？
action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作
vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中
vuex 的 module 是什么？
面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules)。</li></ul> <h2 id="_12-vue-router-有哪几种导航钩子"><a href="#_12-vue-router-有哪几种导航钩子" class="header-anchor">#</a> 12.vue-router 有哪几种导航钩子?</h2> <p>全局导航钩子:</p> <p>router.beforeEach(to, from, next),</p> <p>router.beforeResolve(to, from, next),</p> <p>router.afterEach(to, from ,next)</p> <p>组件内钩子:</p> <p>beforeRouteEnter,</p> <p>beforeRouteUpdate,</p> <p>beforeRouteLeave</p> <p>单独路由独享组件:</p> <p>beforeEnter</p> <h2 id="_13-v-model的原理"><a href="#_13-v-model的原理" class="header-anchor">#</a> 13.v-model的原理？</h2> <p>v-model本质上就是语法糖，即利用v-model绑定数据后，其实就是既绑定了数据，又添加了一个input事件监听</p> <h2 id="_14-vue中key的原理"><a href="#_14-vue中key的原理" class="header-anchor">#</a> 14.vue中key的原理？</h2> <p>作用的话，便于diff算法的更新，key的唯一性，能让算法更快的找到需要更新的dom，需要注意的是，key要唯一，不然会出现很隐蔽性的更新问题。</p> <h2 id="_15-使用vue渲染大量数据时应该怎么优化"><a href="#_15-使用vue渲染大量数据时应该怎么优化" class="header-anchor">#</a> 15.使用vue渲染大量数据时应该怎么优化</h2> <p>Object.freeze
使用方式：this.item = Object.freeze(Object.assign({}, this.item))</p> <h2 id="_16-provide和inject的理解"><a href="#_16-provide和inject的理解" class="header-anchor">#</a> 16.provide和inject的理解</h2> <p>通过在父组件中inject一些数据然后再所有子组件中都可以通过provide获取使用该参数,</p> <p>主要是为了解决一些循环组件比如tree, menu, list等, 传参困难, 并且难以管理的问题, 主要用于组件封装, 常见于一些ui组件库</p> <h2 id="_17-vuex-的mutation和action的特性是什么-有什么区别"><a href="#_17-vuex-的mutation和action的特性是什么-有什么区别" class="header-anchor">#</a> 17.vuex 的mutation和action的特性是什么？有什么区别？</h2> <p>mutation用于修改state的数据，是同步的</p> <p>action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态</p> <p>action 可以包含任意异步操作</p> <h2 id="_18-为什么vue中-data-必须是一个函数"><a href="#_18-为什么vue中-data-必须是一个函数" class="header-anchor">#</a> 18.为什么vue中 data 必须是一个函数？</h2> <p>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：
返回一个唯一的对象，不要和其他组件共用一个对象进行返回!!!每一个实例的data属性都是独立的；</p> <h2 id="_19-axios封装"><a href="#_19-axios封装" class="header-anchor">#</a> 19.axios封装</h2> <p>1.设置axios默认baseURL axios.defaults.baseURL
2.设置axios默认请求数据类型  axios.defaults.headers.common[&quot;Accept&quot;] = &quot;application/json&quot;</p> <h4 id="请求拦截"><a href="#请求拦截" class="header-anchor">#</a> 请求拦截</h4> <p>每次发送请求之前判断vuex中是否存在token,统一在http请求的header都加上token，这样后台根据token判断你的登录情况</p> <h4 id="响应拦截"><a href="#响应拦截" class="header-anchor">#</a> 响应拦截</h4> <p>服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误。</p> <h4 id="登陆token"><a href="#登陆token" class="header-anchor">#</a> 登陆token</h4> <p>如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token.</p> <h4 id="路由拦截"><a href="#路由拦截" class="header-anchor">#</a> 路由拦截</h4> <p>1.处理低版本浏览器
2.仓库中没有token,并且要去的页面不是登陆页，跳转到登陆页
3.权限页面控制和404
利用全局路由钩子beforeEach</p> <h4 id="权限控制"><a href="#权限控制" class="header-anchor">#</a> 权限控制</h4> <p>1 给账号增加角色 不同角色对应不同的权限
2 根据用户信息的权限返回一个权限对象
3 公共方法permission.js处理这个权限对象
4 在路由中meta设置auth. 公共侧边栏利用this.permission(meta.auth)控制页面权限</p> <h2 id="_20-virtual-dom-的优势在哪里"><a href="#_20-virtual-dom-的优势在哪里" class="header-anchor">#</a> 20.Virtual Dom 的优势在哪里？</h2> <blockquote><p>DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎,引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗.</p></blockquote> <ul><li>1.虚拟 DOM 不会立马进行排版与重绘操作</li> <li>2.虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗</li> <li>3.虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部</li></ul> <h2 id="_21-单页应用有那些优缺点"><a href="#_21-单页应用有那些优缺点" class="header-anchor">#</a> 21.单页应用有那些优缺点？</h2> <p>优点：对服务器请求较少，减轻了服务器的压力，只需要一次加载，页面片段之间切换快，用户体验良好
缺点：第一次加载时耗费时间较长，不利于SEO</p> <h2 id="_22-common-js-和-es6-中模块引入的区别"><a href="#_22-common-js-和-es6-中模块引入的区别" class="header-anchor">#</a> 22.common.js 和 es6 中模块引入的区别？</h2> <ul><li>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li> <li>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li> <li>3.CommonJs 是单个值导出，ES6 Module可以导出多个</li></ul> <h2 id="_23-vue3今年发布了-请你说一下他们之间在相应式的实现上有什么区别-proxy-相比于-defineproperty-的优势"><a href="#_23-vue3今年发布了-请你说一下他们之间在相应式的实现上有什么区别-proxy-相比于-defineproperty-的优势" class="header-anchor">#</a> 23.vue3今年发布了，请你说一下他们之间在相应式的实现上有什么区别？Proxy 相比于 defineProperty 的优势</h2> <p>vue2采用的是defineProperty去定义get，set，而vue3改用了proxy.</p> <h4 id="_24-proxy的优势"><a href="#_24-proxy的优势" class="header-anchor">#</a> 24.Proxy的优势</h4> <ul><li>1.可以直接监听对象而非属性</li> <li>2.可以直接监听数组的变化</li> <li>3.Proxy返回一个新对象，可以只操作新对象达到目的，而Object.defineProperty只能遍历对象属性直接修改</li></ul> <h2 id="_25-像vue-router-vuex他们都是作为vue插件-请说一下他们分别都是如何在vue中生效的"><a href="#_25-像vue-router-vuex他们都是作为vue插件-请说一下他们分别都是如何在vue中生效的" class="header-anchor">#</a> 25.像vue-router，vuex他们都是作为vue插件，请说一下他们分别都是如何在vue中生效的？</h2> <p>通过vue的插件系统，用vue.mixin混入到全局，在每个组件的生命周期的某个阶段注入组件实例</p> <h2 id="_26-请你说一下vue的设计架构"><a href="#_26-请你说一下vue的设计架构" class="header-anchor">#</a> 26.请你说一下vue的设计架构</h2> <p>vue2采用的是典型的混入式架构，各部分分模块开发，再通过一个mixin去混入到最终暴露到全局的类上</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/docschina/vuepress/edit/master/docs/vueBase/README.md" target="_blank" rel="noopener noreferrer">编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2/26/2022, 5:27:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/vueBase/vue源码分析.html">
        vue源码分析
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.03951f9c.js" defer></script><script src="/blog/assets/js/2.7ce02919.js" defer></script><script src="/blog/assets/js/11.d6ff424e.js" defer></script>
  </body>
</html>
