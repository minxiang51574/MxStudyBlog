# 三、Vite
Vite是新一代的前端构建工具，在尤雨溪开发Vue3.0的时候诞生。类似于Webpack+ Webpack-dev-server。其主要利用浏览器ESM特性导入组织代码，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。生产中利用Rollup作为打包工具，号称下一代的前端构建工具

## 1、优缺点
优点
- 快速的冷启动: No Bundle + esbuild 预构建
- 即时的模块热更新: 基于ESM的HMR，同时利用浏览器缓存策略提升速度
- 真正的按需加载: 利用浏览器ESM支持，实现真正的按需加载

缺点
 - 生态：目前Vite的生态不如Webapck
- 生产环境由于esbuild对css和代码分割不友好使用Rollup进行打包

## 2、ESM
ESM的执行可以分为三个步骤：

 - 构建: 确定从哪里下载该模块文件、下载并将所有的文件解析为模块记录
 - 实例化: 将模块记录转换为一个模块实例，为所有的模块分配内存空间，依照导出、导入语句把模块指向对应的内存地址。
 - 运行：运行代码，将内存空间填充

 ## 3、Rollup
 在生产环境下，Vite使用Rollup来进行打包

> Rollup是基于ESM的JavaScript打包工具。相比于其他打包工具如Webpack，他总是能打出更小、更快的包。因为 Rollup 基于 ESM 模块，比 Webpack 和 Browserify 使用的 CommonJS模块机制更高效。Rollup的亮点在于同一个地方，一次性加载。能针对源码进行 Tree Shaking(去除那些已被定义但没被使用的代码)，以及 Scope Hoisting 以减小输出文件大小提升运行性能。

Rollup分为build（构建）阶段和output generate（输出生成）阶段。主要过程如下：

- 获取入口文件的内容，包装成module，生成抽象语法树
- 对入口文件抽象语法树进行依赖解析
- 生成最终代码
- 写入目标文件

## 4、对比 Webapck

### 1.和 webpack 对比，为什么 vite 的冷启动、热启动、热更新都会快？这就要说说二者的区别。
使用 webpack 时，从 yarn start 命令启动，到最后页面展示，需要经历的过程：

- 1、以 **entry** 配置项为起点，做一个全量的打包，并生成一个入口文件 index.html 文件；
- 2、启动一个 **node** 服务；
- 3、打开浏览器，去访问入 index.html，然后去加载已经打包好的 js、css 文件；

在整个工作过程中，最重要的就是第一步中的全量打包，中间涉及到构建 module graph (涉及到大量度文件操作、文件内容解析、文件内容转换)、chunk 构建，这个需要消耗大量的时间。尽管在二次启动、热更新过程中，在构建 module graph 中可以充分利用缓存，但随着项目的规模越来越大，整个开发体验也越来越差
> 在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件
> Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写

使用 **vite** 时， 从 **vite** 命令启动，到最后的页面展示，需要经历的过程：

- 1、使用 **esbuild** 预构建依赖，提前将项目的第三方依赖格式化为 **ESM** 模块；
- 2、启动一个 **node** 服务；
- 3、打开浏览器，去访问 index.html；
- 4、基于浏览器已经支持原生的 **ESM** 模块, 逐步去加载入口文件以及入口文件的依赖模块。浏览器发起请求以后，dev server 端会通过 middlewares 对请求做拦截，然后对源文件做 resolve、load、transform、parse 操作，然后再将转换以后的内容发送给浏览器。

在第四步中，vite 需要逐步去加载入口文件以及入口文件的依赖模块，但在实际应用中，这个过程中涉及的模块的数量级并不大，需要的时间也较短。而且在分析模块的依赖关系时， vite 采用的是 esbuild，esbuild 使用 Go 编写，比以 JavaScript 编写的打包器预构建依赖快 10-100 倍（webpack 就是采用 js 

综上，开发模式下 **vite** 比 **webpack** 快的原因：

- 1、**vite** 不需要做全量的打包，这是比 **webpack** 要快的最主要的原因；
- 2、**vite** 在解析模块依赖关系时，利用了 **esbuild**，更快（esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍）；
- 3、按需加载；模块之间的依赖关系的解析由浏览器实现。Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。
- 4、充分利用缓存；**Vite** 利用 **HTTP** 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 **304 Not Modified** 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求


### 2、热更新
webpack 
- 编辑文件后将重新构建文件本身;
- 显然我们不应该重新构建整个包，因为这样更新速度会随着应用体积增长而直线下降；
- 所以打包器支持了动态模块热重载HMR(Hot Module Replacing)，而对页面其余部分没有影响，这较大的提升了开发体验；
- 然而，在实践中发现即使是HMR，更新速度也会随着应用规模的增长而显著下降；

vite 
- 在vite中，HMR是在原生ESM上执行的，当编辑一个文件时，只需要精确地使已编辑的模块与其最近的 HMR边界之间的链失效(大多数时候只需要模块本身)，使HMR更新始终快速，无论应用的大小
- vite同时利用HTTP头来加速整个页面的重新加载(再次让浏览器为我们做更多事情)
  - 源码模块的请求会根据304 Not Modified进行协商缓存
  - 依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable进行强缓存;

### 3、服务启动速度
- webpack需要先把所有的模块建立依赖关系打包成一个大文件，速度相对较慢；

- vite将应用中的模块区分为 依赖(node_modules) 和 源码(项目代码) 两类，进行预构建，速度会快很多；
  - 依赖：使用esbuild预构建，esbuild使用Go编写，比以Node.js编写的打包器预构建依赖快10-100倍；
    - 初次预构建完成后，会在node_modules中生成 .vite文件，后期不需要再次进行依赖的预构建；
  - 源码：在浏览器请求时按需转换并以原生ESM方式提供源码，让浏览器接管了打包程序的部分工作；
    - 由于是按需提供，所以在首屏、懒加载方面相比于webpack会存在一定的差异



### 4.对比 webpack ，优缺点在哪
#### 优点：

更快的冷启动：Vite 借助了浏览器对 ESM 规范的支持，采取了与 Webpack 完全不同的 unbundle 机制
更快的热更新：Vite 采用 unbundle 机制，所以 dev server 在监听到文件发生变化以后，只需要通过 ws 连接通知浏览器去重新加载变化的文件，剩下的工作就交给浏览器去做了。

#### 缺点：

开发环境下首屏加载变慢：由于 unbundle 机制，Vite 首屏期间需要额外做其它工作。不过首屏性能差只发生在 dev server 启动以后第一次加载页面时发生。之后再 reload 页面时，首屏性能会好很多。原因是 dev server 会将之前已经完成转换的内容缓存起来
开发环境下懒加载变慢：跟首屏加载变慢的原因一样。Vite 在懒加载方面的性能也比 Webpack 差。由于 unbundle 机制，动态加载的文件，需要做 resolve、load、transform、parse 操作，并且还有大量的 http 请求，导致懒加载性能也受到影响。
webpack支持的更广。由于 Vite 基于ES Module，所以代码中不可以使用CommonJs；webpack更多的关注兼容性, 而Vite 关注浏览器端的开发体验。Vite目前生态还不如 Webpack

> 当需要打包到生产环境时，Vite使用传统的rollup进行打包，所以，vite的优势是体现在开发阶段，缺点也只是在开发阶段存在。

